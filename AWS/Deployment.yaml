apiVersion: apps/v1
kind: Deployment
metadata:
  name: medisupply-dummy             # Nombre del objeto Deployment
  labels:
    app: medisupply-dummy            # Etiquetas (clave para selección/agrupación)
spec:
  replicas: 2                        # Cuántas réplicas (pods) quieres
  selector:
    matchLabels:
      app: medisupply-dummy          # Debe coincidir con labels del template
  revisionHistoryLimit: 5            # Cuántas revisiones mantiene para rollback
  strategy:
    type: RollingUpdate              # Estrategia de despliegue (actualizaciones sin downtime)
    rollingUpdate:
      maxUnavailable: 0              # No bajes ninguna réplica durante update
      maxSurge: 1                    # Sube 1 réplica extra en el update
  template:
    metadata:
      labels:
        app: medisupply-dummy        # Etiquetas del pod (deben matchear el selector)
    spec:
      serviceAccountName: medisupply-sa
      containers:
        - name: app
          image: 726264870413.dkr.ecr.us-east-1.amazonaws.com/medisupply:latest
          imagePullPolicy: Always   # Evita pulls innecesarios en el nodo
          ports:
            - containerPort: 8080         # Puerto donde escucha tu Flask/Gunicorn
          envFrom:
            - configMapRef:
                name: medisupply-config
            - secretRef:
                name: medisupply-secrets
          readinessProbe:                 # Señal: “estoy listo para recibir tráfico”
            httpGet:
              path: /health
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 5
            timeoutSeconds: 2
            failureThreshold: 3
          livenessProbe:                  # Señal: “sigo vivo”
            httpGet:
              path: /health
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 2
            failureThreshold: 3
          resources:                      # Requests/limits → planificación y protección
            requests:
              cpu: "200m"
              memory: "128Mi"
            limits:
              cpu: "500m"
              memory: "256Mi"

### SERVICE (CLUSTERIP)
---
apiVersion: v1
kind: Service
metadata:
  name: medisupply-dummy-svc
  labels:
    app: medisupply-dummy
spec:
  type: ClusterIP                   # Crea un servicio interno (no expuesto fuera del cluster)
  selector:
    app: medisupply-dummy              # ¿Qué pods atiende este Service? (labels)
  ports:
    - name: http
      port: 80                         # Puerto expuesto por el Service / LB
      targetPort: 8080                 # Puerto del contenedor dentro del pod

### INGRESS (ALB)
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: medisupply-ingress
  annotations:
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
    alb.ingress.kubernetes.io/healthcheck-path: /health
    alb.ingress.kubernetes.io/group.name: medisupply
spec:
  ingressClassName: alb
  rules:
    - http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: medisupply-dummy-svc
                port:
                  number: 80
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: medisupply-config
data:
  FLASK_ENV: "development"
  PORT: "8080"
  DDB_TABLE: "medisupply-demo"
  AWS_REGION: "us-east-1"
  SQS_QUEUE_URL: "https://sqs.us-east-1.amazonaws.com/726264870413/medisupply-events"
---
apiVersion: v1
kind: Secret
metadata:
  name: medisupply-secrets
type: Opaque
stringData:
  API_KEY: "XXX"